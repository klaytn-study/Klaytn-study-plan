# Klaytn study 2회

## 활동 내용

- 인프런 강의([4. 클레이튼 덧셈게임 개발 with Klaytn Tools, 5. 클레이튼 덧셈게임 개발 프론트앤드 6. 마무리](https://www.inflearn.com/course/클레이튼)) 
- 인프런 강의(블록체인과 솔리디티) 수강 후 투표앱 코딩
  - [결과물: 덧셈게임, 인프런 수강 완료 캡쳐 ](https://github.com/klaytn-study/Voting-Ethereum-DApp)
- 비트코인 기본 개념 조사 
- 클레이튼 Docs 조사한 것 공유
-  BApp 기획(앱 주제 선정, 사용 기술 확정, 기능 정리, 일정 계획, 업무 분담)



## 공부 내용



## 비트코인 기본 내용 조사

## 1. 비트코인 블록 구조

 전체 블록의 크기는 1Mbytes로 제한되어 있음. 비트코인의 블록은 헤더와 거래목록으로 구성되며 헤더는 80바이트로 구성되어 있고 거래의 평균 크기는 최소 250 바이트로 구성되어 있음. 평균적으로 블록에는 500개 이상의 거래가 담겨 있음. 따라서 모든 거래가 포함된 후 완성된 블록은 블록 헤더의 크기보다 1000배 정도 큼



#### 헤더

 헤더 안의 데이터를 통해 블록의 hash 값(하나의 블록을 항상 유일하게 식별해주는 값)을 만듦. 



\> *블록 해시는 실제로 블록의 데이터 구조에 포함되어 있지 않음. 블록 해시는 블록이 네트워크로 전송될 때나 블록체인의 일부로 노드의 영구 저장소에 저장될 때에도 데이터 구조에 포함되어 있지 않음. 대신 블록 해시는 해당 블록을 네트워크에서 전송받으면서 각 노드에 의해 계산됨.*



\1. previous hash



   \- 이전 블록헤더를 sha256 해시 함수를 이용하여 2번 해싱한 해시값

   \- 32 바이트



\2. merkle root 



   \- 현재 블록에 포함된 거래정보의 거래 해시를 2진 트리 형태로 구성할 때 트리의 루트에 위치하는 해시값



   \- 32 바이트



   \- 특정 거래가 블록내부에 포함된느지 여부를 검증하는데 효율적인 프로세스를 제공



   \- 상향식으로 두개의 hash값을 두번 해시(double sha256)하여 상위 hash 값 생성 (sha256 사용)



   \- 이진 트리이기 때문에 짝수 개의 리프노드가 필요하며 홀수 개의 경우에는 마지막 노드를 복사하여 짝수로 만들어서 사용



   \- 트랜잭션이 1개 밖에 없으면 merkel root와 tx hash 값이 일치함



   \- 거래가 몇 건이든 머클 루트는 32바이트로 동일함



​     \> *머클 트리 : 블록 내에 있는 모든 거래를 요약하기 위해 비트코인에서 사용됨.*

​     \>

​     \> *머클 루트 : 해시가 하나 남을 때까지 노드 쌍을 반복적으로 해싱해서 머클 트리를 만듦.*



\3. timestamp 



   \- 블록이 생성된 시간

   \- 4 바이트

   \- 1970년 1월 1일 이후의 초단위 시간



\4. bits 



   \- 블록 생성의 난이도



   \- 4 바이트



   \- 비트코인은 평균적으로 약 10분 간격으로 새로운 블록이 채굴되도록 설계되어 있음. 2016개의 블록이 추가 생성되는 2주 간의 간격으로 1개의 블록이 생성되는 주기를 계산하여 평균 약 10분보다 길면 난이도를 어렵게 하고, 10분 간격보다 짧으면 난이도를 쉽게 하여 1개의 새로운 블록이 생성되는 주기를 약 10분 간격이 되도록 조정함. 



​     \> *목표값은 앞의 비트 0의 개수가 많으면 난이도가 높게 될 것*



   \- 새로운 난이도 = 이전 난이도 * (2016개 블록의 실제 시간/20160 분)



\5. version 



   \- 소프트웨어/프로토콜 업그레이드 추적을 위한 



   \- 4 바이트



\6. nonce(number used once)



   \- 작업증명 알고리즘에 사용되는 카운터

   \- 4 바이트

   \- 후보 블록에서 헤더에 version, previous hash, merkle root, timestamp, bit 값은 결정되어 있고, nonce 값은 변경할 수 있음

   \- nonce 값을 초기 0부터 시작해서 1씩 증가시킴



\#### 트랜잭션



\- 노드는 가장 우선순위가 높은 거래를 우선적으로 추가함으로 메모리 풀에 거래를 선택함



  \> *우선순위 = sum(value of input \* input age) / transaction size*

  \>

  \> *value of input은 사토시 단위로 측정.* 

  \>

  \> *input age는 블록체인에 기록된 이후 지나간 시간*

  \>

  \> *transaction size는 바이트 크기로 측정됨*



\- 블록 내부에 있는 거래 공간 중 첫 50킬로바이트는 우선순위가 높은 거래들에게 할당(거래 수수료와 상관 없이)

\- 나머지 공간은 최고 수수료를 가진 거래부터 우선적으로 블록에 담음







\- 블록에 처음으로 추가되는 거래는 코인베이스 거래(채굴에 대한 보상)



\- 채굴에 대한 보상 = 코인베이스 보상금 + 블록에 포함된 모든 거래에서 얻은 거래 수수료



\- 일반적인 거래와 달리 코인베이스 거래는 입력값으로 UTXO 사용 안함 -> 대신 코인베이스라고 불리는 하나의 입력값을 보유하고 있음.



  \> *일반적인 거래의 입력값 구조*

  \>

  \> 1. *거래 해시 : 소비될 UTXO를 담고 있는 거래에 대한 지시자*

  \> 2. *출력값 인덱스 : 소비될 UTXO의 색인번호*

  \> 3. *해제 스크립트 크기 : 따라 나오는 바이트 단위의 해제 스크립트 길이*

  \> 4. *해제 스크립트 : UTXO 잠금 스크립트의 조건을 풀 수 있는 스크립트*

  \> 5. *일련번호 : 현재 장애가 있는 Tx 대체 가능. 0xFFFFFFFF로 설정*



  \> *코인베이스 거래의 입력값 구조*

  \>

  \> 1. *거래 해시 : 모든 비트가 0, 거래 해시 참조 아님*

  \> 2. *출력값 인덱스 : 모든 비트가 1*

  \> 3. *코인베이스 데이터 크기 : 2~100바이트까지 코인베이스 데이터의 길이*

  \> 4. *코인베이스 데이터 : 버전-2 블록에 있는 추가적인 난스와 채굴 태그에서 사용되는 임의적인 데이터*

  \> 5. *일련번호 : 0xFFFFFFFF로 설정*





## 2. 작업증명



기존 블록체인 플랫폼의 약점

Scalability : 확장성

TPS + Block Interval

TPS(Transaction Per Second): 초당 몇개의 거래(트랜젝션)를 처리 가능한가

Block Interval: 블록 생성 간격(시간)



기존 블록체인 플랫폼의 TPS

Visa: TPS 1700

비트코인: TPS 7 (현실적으로는 2~5)

이더리움: TPS 15~20







기존 블록체인 플랫폼의 Block Interval

비트코인: 10분

이더리움: 15초~20초

만약 이더리움(ETH)이 20tps로 Block interval이 15초 나왔다고 하면

20*15 = 300개의 transaction이 한 블록에 들어가게 됨







만약 어떤 블록체인 플랫폼이 TPS가 10,000이고 Block Interval이 10분이라면?

(1초에 10,000개의 트랜잭션을 처리하는데 그 내용들을 담은 블록이 완성하는데 까지는 최대 10분이 걸릴 수 있다는 뜻 )

나는 돈보내고 싶어서 송금버튼을 눌렀는데, 재수없음 최대 10분이 걸릴 수 있음







왜 기존의 블록체인은 느린가?

블록체인 네트워크의 특성: 참여하는 노드가 많아진다해서 빨라지진 않음

웹: 사용자가 많음에 따라 서버를 증가시키고, 다량의 리퀘스트가 들어오면 그 일들을 분산해서 처리하면 됨

그러나 블록체인 네트워크는 100개의 일이 들어오면 이를 분산하지 않고 모든 노드들이 100개의 일을 처리함 => 결과적으론 가장 느린 노드에 맞춰 속도가 하향 평준화 되는 것

=> 컴퓨터 한대로 구성된 퍼포먼스나 100대로 구성된 퍼포먼스나 다르지 않음

기존의 비트코인&이더리움: 많은 양의 트랜잭션 처리하기 부족/네트워크 자체 속도 느림







Finality : 변경 불가능한 최종적인 상태

TX가 변경 불가라는 합리적인 보장을 받기까지 기다려야 하는 시간

블록이 Final 하다는 것: 블록에 담긴 TX(거래)가 바뀔 수 없다는 걸 보증

비트코인과 이더리움은 최종성이 부족함



ex. 비트코인으로 비행기 티켓을 산다 -> 그 순간 TX(트랜잭션) 생성(기록에 남을 수 있는 거래가 생성됨) -> 그러나 이 TX는 바로 처리되지 않음



확률론적 최종성만 제공(비행기 티켓은 결제를 했지만, 나중에 보면 결제가 되어있지 않을 수 있다는 뜻)



Finality에 도달하는데 걸리는 시간 => 이게 길어서 암호화패가 상용화되기 어려운 것

비트코인: 60분(6번의 검증)

이더리움: 6분(25번의 검증)

블록 채굴 평균시간

비트코인: 10분

이더리움: 15초



블록체인 네트워크에서 오랜 시간 기다리는것도 비즈니스에도 상당한 영향을 미칠 수 있기 때문에, 빨리 처리된 Finality는 중요한 business 자산임





Fork: 블록체인의 연결이 2개 이상의 분기로 갈라지는 현상

발생이유: 블록체인 P2P 네트워크에서 모든 참여자들이 독립적으로 채굴을 할 수 있기 때문 

블록채인과 이더리움의 작업증명(PoW) 방식

블록체인에 블록을 추가하기 위해 문제를 풀게 함(Hash 값 찾기)

->여러 노드들이 경쟁을 하면서 먼저 문제를 풀려고 함

->어쩌다 두 노드에서 비슷한 시기에 문제를 풀게 됨

-> 그러면 블록체인에 추가될 후보자로 2개의 블록이 올라가게 됨 => 분기 발생







A노드가 B노드에게 송금을 할때

->TX가 발생하고 TX POOL이라는 곳에 들어감

->A, B 노드에서 블록을 만들기위해 TX POOL에 있는 TX들을 블록에 담음

->노드들이 각자가 만든 블록을 기존의 블록체인에 추가하기 위해 문제를 풀어야 함(Hash 값 찾기)

->어떻게 하다보니 A, B노드 둘 다 문제를 품

->다른 노드들에게 내가 풀었다고 전파를 함

->전파를 받았을 때, 어떤 노드들은 A노드의 블록을 받고, 어떤 노드들은 B노드의 블록을 받음

->전파 과정에서 A노드의 블록을 받은 애들도 B노드의 블록을 받게 되고, B노드의 블록을 받은 애들도 A노드의 블록을 받게 됨

->그러나 이때 그 블록을 안받고 무시하게됨(동일한 TX가 있기 때문)

-> 분기때 더 길게 이어진 라인이 다음 블록으로 인정이되고 블록체인에 추가가 됨 => Longest Chain Rule

그러나 이 규칙을 악의적으로 사용할 수도 있음



만약 전체 컴퓨팅 파워의 51%이상을 가지고 있다면 다른 채굴자보다 더 빨리 채굴이 가능하고 더 많은 블록을 생성할 수 있음 => 분기 과정에서 내가 만든 블록에 계속 라인을 이어나갈수 있게 됨 (다른 노드가 블록 만든 걸 기다릴 필요가 없고 내가 만들어서 추가시키면 됨. hashing power가 더 쎄기 때문에.) -> 나 혼자 라인을 다른 노드들에게 전파를 안하고 몰래 계속 이어나가는게 가능. 이게 어떻게 악용이 되냐 ->내 코인을 팔아서 현금화했다는 기록을 블록에 안 넣을 수 있음. 그러고 나서 전체 네트워크에 내 라인을 등장시키면, 분기때 제일 긴 라인을 선택해서 해당 블록을 블록체인에 추가하는 룰이니까, 이렇게 되면 내 라인이 더 기니까 내 라인이 선택이 되고, 사기친 블록이 블록체인에 합법적으로 추가가 됨.

이런식으로 네트워크를 망가뜨릴 수 있는 가능성이 증가.



누구 라인이 더 긴지 증명과정을 거쳐야 해서 시간이 오래 걸림.

## 3.지갑과 지갑 종류

## 4.거래(tx)의 구조



거래의 최소 단위는 트랜잭션(transaction, ‘Tx’)이라고 하며 트랜잭션이란 더 이상 쪼갤 수 없는 업무 처리의 최소 단위

예를 들어, A라는 사람이 B라는 사람에게 1,000원을 지급하고 B가 그 돈을 받은 경우, 
이 거래 기록은 더 이상 쪼갤 수가 없는 하나의 트랜잭션이다
A가 돈을 지불하고 B가 돈을 받는 행위는 분리 될 수 없는 단일 거래이다

1.거래
하나의 거래에는 6가지 정보가 담긴다.

- 버전 ( 거래가 따르는 규칙, 어떤 버전 소프트웨어 표기)
- 입력값 개수
- 출력값 개수
- 잠금시간 ( 해당 거래가 블록체인에 추가되는 ‘가장 빠른 시간’)
  - 블록체인에 거래가 담기기 전 일정 시간 잠궈두는 것
  - ex) 거래가 10초 뒤에 블록체인에 담기기 원한다면 잠금시간 -> 10 초
  - 대부분은 바로 추가되기 원해서 0을 표기
- 입력값
- 출력값

거래란 소유권을 이전하는 과정
입력값과 출력값은 소유전을 이전하기 위한 준비물과 결과물이다.

블록체인 거래는 UTXO의 소유권을 이전하는 것이다

UTXO(unspent transaction output)
UTXO : 소비되지 않은 거래 출력 값

예시

1. 제임스 하든의 SPV노드(지갑)에서 트랜잭션이 발생 (제임스 하든 지갑 -> 카이리 어빙지갑으로 BTC전달)
2. 제임스 하든의 SPV노드와 이웃관계인 노드들부터 순차적으로 트랜잭션이 공유되며 몇 초안에 모든 노드로 해당 트랜잭션이 공유된다.
3. BLOCKCHAIN 네트워크의 모든 Miner들이 트랜잭션을 저장할 블록을 채굴
4. 몇 분후 채굴자인 스테판 커리의 노드가 채굴경쟁에서 승리하여 블록을 생성
5. 커리의 노드 내부에 존재하는 Block-Chain에 새로 생긴 블록을 연결
6. 커리의 노드와 이웃관계인 노드들부터 순차적으로 해당 블록이 전달되며, 결국 모든 노드들의 Block-Chain에 해당 블록이 저장된다.



## 5.비트코인 노드의 종류



노드란?

하나의 서버 ? 지갑(지갑도 하나의 노드 역할을 한다)?

노드의 정의는 상황에 따라 달라진다. 하지만 대표적으로는 컴퓨터나 통신 네트워크를 이야기 할때(네트워크 노드), 노드는 메시지가 생성되고, 수신되고, 전송되는 지점을 의미한다. —> 통신지점

각 컴퓨터의 노드는 특별한 함수에 의해 정의되며, 이를 통해 다양한 형태의 비트코인 노드가 존재하게 된다.

네트워크에서 연결 포인트 혹은 데이터 전송의종점, 재분배점 등을 의미

거래에 참여하는 개개인의 서버들이 모여 네트워크를 유지 및 관리하는데 이 개개인의 서버, 즉 참여자를 노드라고 한다



노드의 기능 4가지

\1. Wallet

\- 지갑기능

\- 사용자의 개인키와 공개키를 관리하고 거래에 사용되는 주소를 생성하는 기능을 담당



\2. Miner

\- 작업증명(Proof of Work) 알고리즘을 사용하여 10분간의 유효한 거래를 블록으로 생성하고 메인체인에 연결하는 기능을 담당



\3. Full Blockchain

\- 최초의 블럭인 제네시스 블록(??)과 가장 최신의 블록까지 포함한 완전한 블록체인 복사본을 가지고 있습니다.

\- 모든 블록을 다 가지고 있기 때문에 상당한 용량을 차지하게 됩니다.



\4. Network Routing

\- 블록체인상의 P2P 네트워크 전송기능을 담당



4가지 기능의 조합으로 다양한 형태로 노드가 형성





Full Nodes : 풀노드 / reference client

\- 4가지 기능 모두 포함

\- 비트코인에 실제로 보안을 지원하고 제공하는 노드로, 네트워크에 필수적

\- 이 노드는 PoW에 관한 Tx와 블록을 확인하는 과정에 관여하므로 완전한 검증노드라고도 불린다.

\- 풀 노드는 새로운 Tx와 블록들을 블록체인에 전송가능하다.

\- 비트코인 코어로 많이 사용딘다



 Full Blockchain Node

\- 지갑과 채굴이 빠짐

\- 블록체인만 유지

\- 네트워크 기능은 새로 생성된 블록을 이웃노드로부터 전달을 받아 최신상태를 유지하기 위함

\- 네트워크 라우팅 기능과 모든 블록체인 데이터를 가진 형태



Listening Nodes, Super Nodes : 수신노드

\- 이 노드는 공개적

\- 다른 노드와 교류하고 정보를 제공

\- 데이터 소스와 통신 브릿지 역할을 할수 있는 재분배 지점

\- 더 많은 연산 능력과 인터넷 접속이 필요하다



마이너 노드(Miners’ Nodes)

\- 비트코인 블록을 테스트하고 마이닝 하기 위해 병렬적으로 실행

\- 지갑기능은 제외하고 채굴에 특화된 형태의 노드

\- 혼자작업—> 솔로마이너, 그룹 —> 풀 마이너



라이트웨이트 or SPV 클라이언트(Lightweight or SPV Clients)

\- 지갑기능과 네트워크 라우팅 기능만 포함된 노드로 전체 블록체인 데이터는 없이 단순히 거래와 유효성 검증만 가능한 스마트폰에 설치된 지갑 등과 같은 노드입니다.

\- 비트코인 네트워크를 사용하지만 실제로는 전체 노드로 기능하지 않음

\- 블록체인 사본을 보과하지 않음

\- 검증과정에 참여하지 않으므로 네트워크 보안에 기여하지 않음

\- 다른 풀 노드나 슈퍼 노드에 의해 제공되는 정보에 의존

\- 암호 화폐 지갑으로 사용



SPV

\- 라이트 노드는 모든 블록 정보를 가지고 있지 않기 때문에 어떤 새로운 거래 정보를 수신 받았을 경우 이 거래가 정상적인지 모름

\- 그래서 풀 노드에게 블록정보를 요청하여 머클트리를 통해 이거래가 검증된 거래인지 확인한다



스마트 폰에는 full blockchain node와 같은 형태는 사용하지 않음 너무 공간을 많이 차지하니까 무거우니까

모든 노드는 Network Routing 기능을 포함한다.



랜덤 노드, 베이킹 노드????





추가적으로….

만일 개개의 모든 노드가 전체 블록체인을 보관해야 한다면, 아래와 같은 문제가 생길 수 있다. 블록체인의 크기가 점점 커져 100TB에 육박하게 되었다고 생각해보자. 이 정도 수준으로 보관해야하는 블록체인의 크기가 커지면, 오직 소수의 사업가나 기업 형태의 참여자만이 이를 감당할 수 있게 된다. 다수의 일반 사용자들은 ‘라이트 SPV(Simple Payment Verification)’ 노드만들 사용하게 될 것이다. 이렇게 되면, 전체 블록체인의 내역을 가진 소수의 참여자들이 결탁하여, 장부내역을 수정하거나 블록보상량을 바꿔치기 하는 등의 조작행위가 일어날 수 있을 것이다. 단순한 ‘라이트 노드(light node)’로서는 이러한 조작을 감지할 방법이 없다. 물론 ‘전체 블록체인를 소유한 노드(full node)’ 중에서도 선의의 참가자가 있을지 모른다. 그러나 다수의 ‘완전노드(full node)’가 작심하여 블록체인 조작을 시도한다면, 이를 발견하는 시점에서는 이미 늦었다고 봐야 할 것이다. 실제로 비트코인이 현재 이와 비슷한 문제에 처할 위험이 있다고 경고받고 있으며, 해당 문제를 완화시키는 방법에 대하여는 Peter Todd에 의해 논의된 바 있다.



위의 문제를 해결키 위해, 가까운 시일 안에 두 가지의 전략을 추가로 도입할 예정이다. 첫번째로 이더리움도 기본적으로 블록체인 기술을 바탕으로 한 채굴 알고리즘을 사용하고 있기 때문에, 모든 채굴자들은 ‘완전노드(full node)’가 되도록 의무화 될 것이며, 이는 필요한 최소한의 완전노드 숫자를 확보할 수 있도록 해줄 것이다 . 두번째로, 이체내역 검증 작업 이후 블록체인에 ‘중간상태 트리루트(an intermediate state tree root)’를 도입하는 것이다. 이렇게 되면, 아무리 블록생성 작업이 소수의 노드에 집중되더라도, 단 하나의 선의의 노드(honest node)만 존재한다면 검증 프로토콜(verification protocol)을 통해 이 문제를 해결할 수 있다.



만일 어떠한 채굴노드가 전파한 블록이 검증오류(invalid)처리가 되었다면, 해당 블록의 ‘구성(format)’이 맞지 않거나 ‘상태내역 S [ n ]’이 틀린 경우일 것이다. ‘S [ 0 ]’ 상태가 옳은 것으로 간주되기 때문에, ‘S[ i-1 ]’이 맞다면, ‘S[ i ]’에 오류가 있는 것이다. 검증작업에 참여하는 노드는, ‘APPLY(S[i-1],TX[i]) -> S[i]’ 작업(processing)을 하는 ‘페트리샤 트리 노드의 부분집합(the subset of Patricia tree)’을 통해 ‘검증오류증명(proof of invalidity)’과 ‘인덱스 i’를 제공한다. 노드들은, 위의 노드들을 이용해 해당 작업을 수행하며, 생성한 ‘S[ i ]’가 제공받은 ‘S[ i ]’와 일치하지 않음을 발견하게 된다.



또한 ‘불완전한 블록(incomplete block)’을 전파하려는 악의의 채굴노드들과 관련된 더욱 정교한 공격이 이루어질 수 있다. 블록을 검증하는데에 필요한 정보가 온전히 존재하지 않을 수도 있다. 이 경우, ‘질의-응답프로토콜(challenge-response protocol)’ 기법이 사용될 수 있다. 검증노드가 ‘목표 블록의 인덱스 형태(target transaction indices)’로 ‘질문(challenge)’을 생성하고, 노드를 수신하는 라이트노드(light node)는 해당 블록(challenge)을 일단 검증오류블록으로 취급한다. 이후, 다른 노드(채굴노드이든 검증노드이든)가 ‘페트리샤 트리 노드의 부분집합(the subset of Patricia tree)’을 검증증명(proof of validity)으로써 제공한다면, 그때서 위의 블록은 검증된(유효한) 것으로 취급된다.





## 클레이튼 Docs

## 1.Basic

**트랜잭션**

**트랜잭션 개요**

블록체인 플랫폼에서의 트랜잭션은 블록체인 상태를 변경하는 노드 간에 전송되는 메시지다. 그 예로 앨리스의 계정에서 밥 계정으로 10KLAY를 보낼 때. 앨리스의 잔액은 10KLAY 감소하고 밥의 잔액은 10KLAY 증가한다. 거래는 atomic하게 작동하기 때문에 다른 거래와 연계(인터리브)될 수 없다는 점에 주의하자. 

일반적인 블록체인 거래에는 다음과 같은 요소가 있다.



**{\*atomic : 따로따로 놀아서는 안되는 동작}**



구성요소 : 설명

value : 전송할 peb의 클레이 양

to : 클레이를 받을 계정주소

input : 트랜잭션에 첨부된 데이터, 트랜잭션 실행에 사용되는 데이터

v, r, s : 수신자가 송신자의 수조를 얻을 수 있도록 하기 위해 송신자가 생성한 암호 서명

nonce : 빌신자의 트랜잭션을 고유하게 식별하는 데 사용되는 값. 발신자가 동일한 nonce 값을 가진 두개의 트랜잭션을 생성하면, 한개의 트랜잭션만 실행된다.

gas : 트랙잭션이 허용되는 최대 거래 수수료

gasPrice : 송신자가 얼마의 토큰을 지불해야 하는지 알수 있는 곱셈기..?

송신자가 지불하는 토큰의 양은 gas* gasPrice를 통해 계산된다.

{

​	**peb은 가장 작은 통화 단위다.**

​	ston은 gpeb의 가명으로 편의상 도입되었다.

​	KLAY는 10^18 peb이다.

}

{

​	Gas Limit: 사용할 가스에 대한 예측치 / 넉넉하면 좋지만, 너무 높을 시 거절 당할 수 있음

​	Gas Price: Gas Limit에서 1 Gas 당 가격, 높을 수록 빨리 실행된다.

​	총 비용 : Gas Limit 중 실제 사용량 * Gas Price

​	Block Gas Limit: 한 블록에 넣을 수 있는 Gas Limit의 총합

}



**클레이튼 트랜잭션**

일반적인 블록체인 플랫폼은 단일 트랜잭션 유형을 제공하지만, Klaytn은 메모리 설치 공간과 성능에 대한 최적화 및 새로운 기능으로 트랜잭션을 강화하는 여러 트랜잭션 유형을 제공한다.



**트랜잭션의 시그니처 검증**

일반적인 블록체인 플랫폼에서 주소는 트랜잭션 서명으로부터 다시 파생되는 공개 키에서 파생된다. 이는 주소와 키 쌍이 강하게 결합되어야만 가능하다.

Key pair는 Klaytn의 주소에 의해서 분리되므로, 송신자 주소는 거래 서명을 사용하여 도출할 수 없다.??

이것이 TxTypeLegacyTransaction을 제외한 Klaytn 트랜잭션 유형이 field from을 가지는 이유다. Klaytn에서 트랜잭션의 유효성을 검사하기 위해, AccountKey of from을 획득하고, 얻은 키를 사용하여 트랜잭션 서명의 유효성을 검사한다.



**수수료 위임**

기업들에게 그들의 사업 모델 설계에 필요한 유연성을 제공하기 위해, Klaytn은 기본 거래 유형에 대해 다양한 수수료 위임 버전을 제공한다. 이러한 변형(다양성)들은 서비스 제공자들이 그들의 거래 수수료를 대신 지불함으로써 그들의 최종 사용자 활동에 보조금을 지급할 수 있게 한다. 거래 수수료 보조금은 비율 매개 변수를 가진 거래를 사용하여 더 자세히 설명할 수 있으며, 서비스 제공자가 커버할 수수료 비율을 지정할 수 있다. 수수료 거래에는 적어도 두 개의 서명이 필요하다. 송신자와 수수료 지불자



**SenderTxHash**

SenderTxHash는 수수료 지불자의 주소와 서명이 없는 거래의 해시이다. 수수료 부과 거래의 거래 해시는 수수료 지급자가 거래에 서명할 때까지 아직 결정되지 않는다. 수수료 위임 거래를 추적하기 위해, 송신자는 송신자와 수수료 지불자 모두의 서명이 포함된 완전한 거래에서 파생된 거래 해시를 얻어야 한다. 송신자가 트랜잭션 해시를 얻는 것이 매우 어렵기 때문에, Klaytn은 트랜잭션 해시뿐만 아니라 SenderTxHash를 제공한다. Klaytn 네트워크에서 완전한 수수료 위임 트랜잭션을 찾기 위해, 송신자는 SenderTxHash를 생성하고 klay_getTransactionBySenderTxHash를 통해 트랜잭션 개체를 요청한다. SenderTxHash를 얻는 방법은 각 트랜잭션 유형에 따라 달라지며, 이는 각 트랜잭션 유형에 대한 설명에 설명되어 있다.

각 트랜잭션 유형은 다음과 같이 자세히 설명되어 있다.

https://docs.klaytn.com/klaytn/design/transactions



**Basic**



**TxTypeLegacyTransaction**

TxTypeLegacyTransaction은 Klaytn에서 이전에 존재했던 트랜잭션의 유형을 나타낸다. 이 트랜잭션 유형은 호환성을 지원하기 위해 존재하므로 AccountKeyLegacy와 관련된 EOA에서만 작동한다. 다른 계정 키 유형과 관련된 EOA는 TxTypeValueTransfer, TxTypeSmartContractExecution 등과 같은 다른 트랜잭션 유형을 사용해야 한다. 이러한 유형의 거래는 계정을 만들거나, 토큰을 양도하거나, 스마트 계약을 구축하거나, 스마트 계약을 실행하거나, 앞서 언급한 혼합을 수행할 수 있다. 이 거래 유형은 다음과 같은 변경을 시작할 것이다.

\1. 발신자의 잔액은 거래 수수료의 금액만큼 감소한다.

\2. 발신자의 nonce가 1씩 증가한다.

\3. 수신자가 Klaytn에 존재하지 않는 경우 AccountKeyLegacy와 연관된 EOA가 생성된다.

\4. 발송된 KLAY 는 송신자에서 수신자에게 이전된다.

\5. 수신자가 없으면 스마트 계약 구축 거래로 본다. 스마트 계약 코드는 반드시 input 데이터 값으로 통과해야 한다.

\6. 수신자가 스마트 계약인 경우, input에 명시된 스마트 계약 기능을 실행한다.



attr / type

value : *big.Int (Go)

to : *common.Address (Go)

input : []byte (Go)

v, r, s : *big.Int (Go)

nonce : uint64 (Go)

gas : uint64 (Go)

gasPrice : *big.Int (Go)



**TxTypeValueTransfer**

TxTypeValueTransfer는 사용자가 토큰을 보내고 싶을 때 사용한다. Klaytn은 각 거래 유형이 하나의 목적에 봉사하도록 여러 거래 유형을 제공하므로, TxTypeValueTransfer는 외부 소유의 계정에 토큰을 보내는 것으로 제한된다. 따라서 TxTypeValueTransfer는 외부 소유 계정인 경우에만 허용된다. KLAY를 스마트 계약 계정으로 전송하려면 대신 TxTypeSmartContractExecution을 사용해야한다. 

이 거래 유형에 따라 다음과 같은 변경이 이루어질 것이다.

\1. 발신자의 잔액은 거래 수수료의 금액만큼 감소한다.

\2. 발신자의 nonce이 1씩 증가한다.

\3. 발송된 KLAY는 송신자에서 수신자에게 이전된다.



attrs : type, nonce, gasPrice, gas, to, value, from, txSignatures

type : uint8 (Go)

\- TxTypeValueTransfer의 유형. 이것은 0x08이어야 한다.

from : common.Address (Go)

\- 보낸 사람의 주소

txSignatures : []{*big.Int, *big.Int, *big.Int} (Go)

\- 보낸 사람의 서명

위의 두개는 Signature Validation of Transactions

중복은 제외함



**TxTypeValueTransferMemo**

TxTypeValueTransferMemo는 사용자가 특정 메시지와 함께 토큰을 보내고 싶을 때 사용된다. TxTypeValueTransferMemo는 외부 소유 계정인 경우에만 허용된다. KLAY를 스마트 계약 계정으로 전송하려면 대신 TxTypeSmartContractExecution을 사용하십시오. 이 거래 유형에 따라 다음과 같은 변경이 이루어질 것이다.

\1. 발신자의 잔액은 거래 수수료의 금액만큼 감소한다.

\2. 발신자의 nonce가 1씩 증가한다.

\3. 발송된 KLAY는 송신자에서 수신자에게 이전된다.



attrs : type, nonce, gasPrice, gas, to, value, from, input, txSignatures





**TxTypeSmartContractDeploy**

TxTypeSmartContractDeploy는 주어진 주소에 스마트 계약을 배포한다. 

이 거래 유형에 따라 다음과 같은 변경이 이루어질 것이다.

\1. 발신자의 잔액은 거래 수수료의 금액만큼 감소한다.

\2. 발신자의 nonce가 1씩 증가한다.

\3. 스마트 컨트랙트는 input의 코드로 전개된다. 배치된 주소는 영수증의 contractAddress를 통해 반환된다

\4. 발송된 KLAY는 송신자에서 수신자에게 이전된다.



attrs : type, nonce, gasPrice, gas, to, value, from, input, humanReadable, codeFormat, txSignatures



humanReadable : bool (Go)

\- 사람이 읽을 수 있는 주소는 아직 지원되지 않으므로 이것은 거짓임에 틀림없다. 만약 true라면 그 거래는 거부된다 <—ㅋㅋ?

codeFormat : uint8 (Go)

\- 스마트 컨트랙트 코드의 코드형식. 현재 지원되는 값은 EVM(0x00) 뿐이다



**TxTypeSmartContractExecution**

TxTypeSmartContractExecution은 "input"에서 주어진 데이터와 스마트 계약을 실행한다. TxTypeSmartContractExecution은 “to”가 스마트 계약 계정인 경우에만 허용된다. KLAY를 외부 소유의 계정으로 전송하려면 대신 TxTypeValueTransfer를 사용하십시오. 

이 거래 유형에 따라 다음과 같은 변경이 이루어질 것이다.

\1. “to"가 스마트 계약 계정인 경우, 코드는 "input"에 근거해 실행된다. 그렇지 않으면, 이 거래는 거부될 것이다.

\2. 발신자의 잔액은 거래 수수료의 금액만큼 감소한다.

\3. 발신자의 “nonce”가 1씩 증가한다.

\4. “value”이 제공된 경우, “value” KLAY는 발신자에서 스마트 계약으로 이전된다. 계약에는 KLAY를 받기 위한 지급불능이 있어야 한다.



attrs : type, nonce, gasPrice, gas, to, value, from, txSignatures



TxTypeAccountUpdate

TxTypeAccountUpdate는 지정된 계정의 키를 업데이트한다. 이 거래 유형에 따라 다음과 같은 변경 사항이 적용될 것이다.

\1. 발신자의 잔액은 거래 수수료의 금액만큼 감소한다.

\2. 발신자의 nonce가 1씩 증가한다.

\3. 계정의 키는 “key”로 갱신된다.

\4. 일단 이러한 유형의 거래가 실행되면, 이후에 계좌에서 전송된 거래는 새로운 “key”로 검증될 것이다.



attrs : type, nonce, gasPrice, gas, from, key, txSignatures

key : AccountKey (Go)

\- 계정에 업데이트할 계정 키





**TxTypeCancel**

TxTypeCancel은 트랜잭션 풀에서 동일한 비활성 상태의 트랜잭션 실행을 취소한다. 이 거래 유형은 제출된 거래가 일정 기간 동안 처리되지 않은 것처럼 보일 때 유용하다. 

거래가 처리되지 않은 것처럼 보이는 몇 가지 사례가 있다: 

\1. 그 거래는 어딘가에서 분실되어 합의된 노드들 중 어느 것도 도달하지 못했다. 

\2. 거래는 아직 합의된 노드에서 처리되지 않았다. 

\3. 거래는 처리되었지만 거래가 포함된 블록은 수신되지 않았다.

고객측에서는 그 이유를 파악하기 위해서는 모든 합의 노드 내부를 살펴야 하기 때문에 정확한 이유를 파악하기 매우 어렵다. 단, 일반인의 합의된 노드에 연결하는 것은 금지된다. 이러한 상황에서, 전형적인 블록체인 플랫폼에서, 사용자는 종종 이전 거래를 대체하기 위해 더 높은 가스 가격으로 다른 거래를 제출한다. 단, 클라이튼에서는 가스 가격이 고정되어 있기 때문에, 이전 거래의 가격을 더 높은 가스 가격으로 대체하는 것은 적용할 수 없다.

거래가 처리되지 않은 상태로 유지되면 nonce가 거래의 실행 순서를 결정하므로 nonce가 높은 다른 거래는 처리할 수 없다.

이 문제를 해결하기 위해 Klaytn은 트랜잭션 유형 TxTypeCancel을 제공한다. 사용자가 이러한 상황에 처했을 경우, TxTypeCancel의 거래를 제출할 수 있다.

위의 각 상황은 다음과 같이 처리된다. 

\1. 이전 거래가 손실된 경우 이 TxTypeCancel 트랜잭션을 실행하여 블록에 포함시킨다.

\2. 이전 트랜잭션을 아직 처리하지 않은 경우 이 TxTypeCancel은 이전 트랜잭션을 대체한다. 그 후 실행되어 블록에 포함된다.

\3. 구거래가 이미 실행되었다면 비전이 증가하였으므로 이 TxTypeCancel 거래는 비전이 낮아 폐기된다.

TxTypeCancel 트랜잭션은 동일한 nonce로 트랜잭션을 대체할 수 있는 유일한 트랜잭션이라는 점에 유의하십시오. 다른 거래 유형은 거래를 동일한 nonce로 대체할 수 없다.

이 거래 유형에 따라 다음과 같은 변경이 발생할 수 있다. 

\1. 발신자의 잔액은 거래 수수료의 금액만큼 감소한다. 

\2. 발신자의 nonce가 1씩 증가한다.



attrs : type, nonce, gasPrice, gas, from, txSignatures



결과:

\1. 동일한 nonce로 거래가 있는 경우, 이 취소 거래로 대체된다.

\2. 동일하지 않은 경우, 이 거래는 그냥 정상적인 거래로 삽입된다. 

\3. 취소 거래는 다른 거래 유형으로 대체되지 않는다.

attrs : type, nonce, gasPrice, gas, from, txSignatures



**TxTypeChainDataAnchoring**

TxTypeChainDataAnchoringTransaction은 서비스 체인에 의해 사용될 트랜잭션 유형이다. 서비스 체인은 서비스 체인의 데이터 무결성을 입증하기 위해 주기적으로 이러한 유형의 트랜잭션을 Klaytn 메인체인으로 전송한다. 서비스 체인에 대한 자세한 내용은 서비스 체인 네트워크를 참조하십시오. RPC를 통한 이 유형의 거래는 허용되지 않는다. 현재 구현에서는 보안상의 이유로 개인 p2p 채널을 사용하여 TxTypeChainDataAnchoring 트랜잭션을 전송한다. 이 거래 유형은 발신자의 nonce가 1씩 증가되는 것을 제외하고는 클라이튼 블록체인 상태를 변경하지 않는다.



attrs : type, nonce, gasPrice, gas, from, txSignatures





각 트랜잭션 유형들에 대한 RLP Encoding 방법들이 제시된다



RLP Encoding for Signature

RLP Encoding for SenderTxHash

RLP Encoding for Transaction Hash

위를 만드는 방법들

RLP Encoding 예시, 출려값

## 2. Accounts

\#### 클라인 계정



\### 계정, 주 및 주소 개요



Klaytn의 계정은 개인의 잔액 또는 스마트 컨트렉트에 대한 정보가 포함 된 데이터 구조

 Klaytn의 상태는 계정에 저장된 모든 데이터의 과거 및 현재 상태를 수집 한 것



\### 여러 키 쌍 및 역할 기반 키

 Klaytn 계정은 다음 기능을 제공



\- 계정과 연결된 키 페어를 변경 가능  

\- Klaytn 계정은 각 키를 다른 목적으로 할당하는 기능과 함께 여러 키 페어를 지원

\- Klaytn 계정은 주소와 강력하게 연결된 단일 키를 가진 계정과의 호환성을 유지



최종 사용자는 Klaytn 계정의 역할 기반 다중 키 지원을 사용하여 개인 키 잘못 관리와 같은 실제 보안 위험 상황을보다 잘 처리 할 수 있다. 예를 들어, 사용자가 자신의 개인 키가 노출되었다는 것을 알게되면 사용자는 자신의 계정에서 노출 된 키 쌍을 제거하고이를 대체 할 새 키 쌍을 만들어 손상된 개인 키를 간단히 교체 할 수 있다. 이를 위해서는 계정 정보를 업데이트하는 데 사용되는 전용 키를 사용하여 미리 생성하여 손상된 개인 키와 별도로 저장하면 된다.



\## 사람이 읽을 수 있는 주소 (HRA)



주소 체계 (예 : "0x0fe2e20716753082222b52e753854f40afddffd2")는 계정 소유자의 개인 정보를 효율적으로 보호한다는 점에서 고유 한 장점이 있지만 최종 사용자 경험 측면에서 주요 문제도 제안한다. 



첫째, 인간의 두뇌가 그러한 주소를 암기하거나 인식하기가 매우 어렵기 때문에 입력 실수와 다양한 인적 오류가 발생하여 사소한 재정적 손해를 입히는 경향이 있다. 



둘째, 이러한 체계는 최종 사용자로부터 기억하거나 사용하기 쉬운 자신의 선호하는 ID 핸들을 선택할 수있는 힘을 빼앗는다다. 대규모로 아키텍처를 수정하지 않고 이전 버전과의 호환성을 유지하지 않고 이러한 문제를 극복하기 위해 Klaytn은 최종 사용자가 자신이 선호하는 값을 할당 할 수있는 20 바이트 주소와 20 바이트 길이의 텍스트 문자열을 매핑하도록 선택한다. Klaytn의이 기능을 사람이 읽을 수있는 주소 (HRA)라고 한다다. 현재 이 기능은 개발 중이다.



\### Klaytn Wallet 키 형식



Klaytn 월렛 키 형식은 해당 주소와 함께 개인 키를 쉽게 처리 할 수 있도록 제공됩니다. 사용자는 자신의 개인 키를 주소와 함께 쉽게 관리 할 수 있습니다. 형식은 16 진수 표기법으로되어 있어야합니다 . 다른 값은 예약되어 있습니다. 예는 다음과 같습니다.`0x{private key}0x{type}0x{address in hex}``{type}``00`



\### Klaytn 계정 유형



Klaytn에는 두 가지 유형의 계정 존재



\- 외부 소유 계정 (EOA) 

\- 스마트 계약 계정 (SCA)



\### 외부 소유 계정 (EOA)



외부 소유 계정에는 nonce 및 balance와 같은 정보가 있다. 이 유형의 계정에는 코드 또는 저장소가 없다. EOA는 개인 키로 제어되며 관련 키가 없다. 키 페어를 사용하여 EOA를 생성 한 후 키 페어를 가진 사람이 제어 할 수 있다. 



계정 키는 섹션에 설명 된 계정 키.



\### 스마트 계약 계정 (SCA)



EOA와 달리 SCA에는 관련 코드가 있으며 해당 코드로 제어된다. SCA는 스마트 계약 배포 트랜잭션에 의해 생성 된다. 일단 배치되면 SCA는 자체적으로 새 트랜잭션을 시작할 수 없으며 EOA 또는 다른 SCA에 의해 다른 계정에 의해 트리거되어야 한다.



\### 계정 키



계정 키는 계정과 관련된 키 구조를 나타낸다.



\### AccountKeyNil



AccountKeyNil은 빈 키를 나타낸다. 계정에 AccountKeyNil 개체가 있으면 트랜잭션이 실패한다. AccountKeyNil은 역할 기반 키가있는 TxTypeAccountUpdate 트랜잭션에만 사용된다. 예를 들어, 계정이 RoleAccountUpdate 키만 업데이트하려고하면 TxTypeAccountUpdate 트랜잭션의 키 필드는 다음과 같다.



[AccountKeyNil, NewKey, AccountKeyNil]



\### RLP 인코딩



0x80



\### AccountKeyLegacy



AccountKeyLegacy는 해당 키 쌍에서 파생 된 주소를 가진 계정에 사용된다. 계정에 AccountKeyLegacy가있는 경우 트랜잭션 유효성 검사 프로세스는 다음과 같이 수행된다 (일반 블록 체인 플랫폼과 동일).



\- 에서 공개 키를 가져온다 .`ecrecover(txhash, txsig)`

\- 공개 키의 주소를 가져온다.

\- 주소는 발신자



\### 속성



| 속성 | 유형         | 기술                                             |

| ---- | ------------ | ------------------------------------------------ |

| 유형 | uint8 (이동) | AccountKeyLegacy의 유형입니다. 0x01이어야합니다. |



\### RLP 인코딩



0x01c0



\## AccountKeyPublic



AccountKeyPublic은 공개 키가 하나 인 계정에 사용된다.



계정에 AccountKeyPublic 개체가있는 경우 트랜잭션 유효성 검사 프로세스는 다음과 같이 수행



\- 에서 파생 된 공개 키를 가져옴 .`ecrecover(txhash, txsig)`



\- 파생 된 공개 키가 해당 공개 키와 동일한 지 확인



  계정의 공개 키



\### 속성



| 속성 | 유형               | 기술                                         |

| ---- | ------------------ | -------------------------------------------- |

| 유형 | uint8 (이동)       | AccountKeyPublic의 유형입니다. 0x02 여야한다 |

| 키   | [33] 바이트 (이동) | 키는 S256 곡선에서 압축 된 공개 키 여야한다  |



\### RLP 인코딩



0x02 + encode(CompressedPubKey)



**



참고**: CompressedPubKey는 [SEC1에](https://www.secg.org/SEC1-Ver-1.0.pdf)정의 된 압축 형식의 공개 키입니다 . 즉, PubkeyY가 짝수이면 0x02 {PubkeyX}이고, 그렇지 않으면 0x03 {PubkeyX}입니다.



\### RLP 인코딩 (예)







\```

prvkey 0xf8cc7c3813ad23817466b1802ee805ee417001fcce9376ab8728c92dd8ea0a6b

pubkeyX 0xdbac81e8486d68eac4e6ef9db617f7fbd79a04a3b323c982a09cdfc61f0ae0e8

pubkeyY 0x906d7170ba349c86879fb8006134cbf57bda9db9214a90b607b6b4ab57fc026e





RLP : 0x02a102dbac81e8486d68eac4e6ef9db617f7fbd79a04a3b323c982a09cdfc61f0ae0e8 

\```



\## AccountKeyFail



계정에 AccountKeyFail 키가있는 경우 트랜잭션 유효성 검사 프로세스는 항상 실패한다. 스마트 계약 계정에서 전송 된 트랜잭션이 항상 실패하도록 스마트 계약 계정에 사용할 수 있다.



\### 속성



| 속성 | 유형         | 기술                                        |

| ---- | ------------ | ------------------------------------------- |

| 유형 | uint8 (이동) | AcccountKeyFail의 유형입니다. 0x03이어야 함 |



\### RLP 인코딩



0x03c0



\## AccountKeyWeightedMultiSig



AccountKeyWeightedMultiSig는 임계 값과 WeightedPublicKeys를 포함하는 계정 키 유형으로, 항목이 공개 키와 가중치로 구성된 목록을 포함한다. AccountKeyWeightedMultiSig와 연관된 계정에 대한 유효한 트랜잭션이 되려면 서명 된 공개 키의 가중치 합계가 임계 값보다 커야한다.



\### 속성



| 속성         | 유형                        | 기술                                                         |

| ------------ | --------------------------- | ------------------------------------------------------------ |

| 유형         | uint8 (이동)                | AccountKeyWeightedMultiSig의 유형입니다. 0x04 여야험         |

| 문지방       | uint (이동)                 | 검증 임계 값. 유효한 거래가 되려면 서명의 가중치 합계가 임계 값 이상이어야함 |

| 가중 공개 키 | [] {uint, [33] byte} (이동) | 가중 공개 키 목록. 가중 공개 키에는 압축 된 공개 키와 그 가중치가 포함된다. |



\### 



****AccountKeyRoleBased****



AccountKeyRoleBased는 역할 기반 키를 나타냄



\### 속성



\- 유형 : uint8

\- 열쇠 : [] {AccountKey} (이동)



\### 역할



AccountKeyRoleBased의 역할은 다음과 같이 정의



\- 역할 거래



\- RoleAccountUpdate



\- RoleFeePayer



\### RLP 인코딩



0x05 + encode([key1, key2, key3])

## 

## 3. Partial Fee Delegation

TxTypeFeeDelegatedValueTransferWithRatio는 유저가 토큰을 보내고 싶을 때 사용된다. Klaytn은 각각의 트렌젝션 타입이 하나의 목적만을 갖도록 하기 위해 다양한 트렌젝션 타입을 제공하기 때문에, TxTypeFeeDelegatedValueTransferWithRatio은 외부 소유의 계정에 토큰을 보내는 것이 제한되어 있다. 따라서 TxTypeFeeDelegatedValueTransferWithRatio 은 오직 to가 외부 소유의 계정일 때에만 받아들여진다. KLAY를 스마트 계약 약정으로 전송하려면 이거 말고 TxTypeFeeDelegatedSmartContractExecutionWithRatio을 사용해라. 이 트렌젝션 타입에 따라 다음과 같은 변경이 이루어질 것이다.

\1. 수수료 납부자의 잔액은 거래 수수료의 일정 비율만큼 감소한다.



\2. 송신자의 잔액은 남은 거래 수수료에 의해 감소한다. 예를 들어, 만약 feeRatio가 30%이라면, ce수수료 납부자가 수수료의 30%를 지불하고, 나머지 70%는 sender가 지불한다.



\3. 송신자의 nonce가 1로 증가한다.



\4. value KLAY 가 송신자로부터 수신자로 이동된다. 



TxTypeFeeDelegatedValueTransferMemoWithRatio는 유저가 특정한 메세지와 함께 토큰을 보내고자 할 때 사용된다. TxTypeFeeDelegatedValueTransferMemoWithRatio는 오직 to가 외부 소유의 계정일 때에만 받아들여진다. KLAY를 스마트 계약 약정으로 전송하려면 이거 말고 TxTypeFeeDelegatedSmartContractExecutionWithRatio을 사용해라. 이 트렌젝션 타입에 따라 다음과 같은 변경이 이루어질 것이다.

 	1. 수수료 납부자의 잔액은 거래 수수료의 일정 비율만큼 감소한다.

 	2. 송신자의 잔액은 남은 거래 수수료에 의해 감소한다. 예를 들어, 만약 feeRatio가 30%이라면, ce수수료 납부자가 수수료의 30%를 지불하고, 나머지 70%는 sender가 지불한다.

 	3. 송신자의 nonce가 1로 증가한다.

 	4. value KLAY 가 송신자로부터 수신자로 이동된다. 



TxTypeFeeDelegatedSmartContractDeployWithRatio는 스마트 계약 약정을 구축한다. 트렌젝션 수수료는 수수료 납부자가 부담한다. 이 트렌젝션 타입에 따라 다음과 같은 변경이 이루어질 것이다.



​	1. 수수료 납부자의 잔액은 거래 수수료의 일정 비율만큼 감소한다.



\2. 송신자의 잔액은 남은 거래 수수료에 의해 감소한다. 예를 들어, 만약 feeRatio가 30%이라면, ce수수료 납부자가 수수료의 30%를 지불하고, 나머지 70%는 sender가 지불한다.



\3. 송신자의 nonce가 1로 증가한다.



\4. input 안의 코드와 함께 스마트 계약이 구축된다. 구축된 주소는 영수증의 contractAddress로 전송될 것이다.



\5. value KLAY 가 송신자로부터 수신자로 이동된다. 



TxTypeFeeDelegatedSmartContractExecution는 input안의 데이터를 통해 스마트 계약을 실행한다. 

TxTypeFeeDelegatedSmartContractExecution은 오직 to가 스마트 계약일 경우에만 받아들여진다. KLAY를 외부 소유 계정으로 전환할 때는, TxTypeFeeDelegatedValueTransferWithRatio를 사용해라. 이 트렌젝션 타입에 따라 다음과 같은 변경이 이루어질 것이다.



​	1.	to가 스마트 계약일 경우, input를 바탕으로 코드가 실행된다. 그렇지 않으면, 이는 거부될 것이다.

​	2.	수수료 납부자의 잔액은 거래 수수료의 일정 비율만큼 감소한다.

​	3.	송신자의 잔액은 남은 거래 수수료에 의해 감소한다. 예를 들어, 만약 feeRatio가 30%이라면, ce수수료 납부자가 수수료의 30%를 지불하고, 나머지 70%는 sender가 지불한다.

​	4.	송신자의 nonce가 1로 증가한다.

​	5.	value 가 제공되었다면, value KLAY는 송신자로부터 스마트 계약으로 전송된다. 계약에는 KLAY를 받기 위한 fallback 함수가 있어야 한다.





TxTypeFeeDelegatedAccountUpdateWithRatio는 주어진 계정의 key를 업데이트한다. 거래 수수료의 비율은 수수료 납부자가 지불한다. 이 트렌젝션 타입에 따라 다음과 같은 변경이 이루어질 것이다.



​	1.	수수료 납부자의 잔액은 거래 수수료의 일정 비율만큼 감소한다.

​	2.	송신자의 잔액은 남은 거래 수수료에 의해 감소한다. 예를 들어, 만약 feeRatio가 30%이라면, ce수수료 납부자가 수수료의 30%를 지불하고, 나머지 70%는 sender가 지불한다.

​	3.	송신자의 nonce가 1로 증가한다.

​	4.	계정의 key가 key를 통해 업데이트 된다.

​	5.	이 트렌젝션이 실행되면, 이후에 계정에서 보내지는 트렌젝션은 이 key를 통해 인증될 것이다.





TxTypeFeeDelegatedCancelWithRatio는 트렌젝션 풀에서 같은 nonce가 있는 트렌젝션의 실행을 취소시킨다. 더 많은 정보를 알고 싶다면, TxTypeCancel를 찾아봐라. 이 트렌젝션 타입에 따라 다음과 같은 변경이 이루어질 것이다.



​	1.	수수료 납부자의 잔액은 거래 수수료의 일정 비율만큼 감소한다.

​	2.	송신자의 잔액은 남은 거래 수수료에 의해 감소한다. 

​	3.	송신자의 nonce가 1로 증가한다.







## 4. Fee delegation





\#### TxTypeFeeDelegatedValueTransfer



- 사용자가 토큰을 보내고 싶을 때 사용

\- 단, 외부 소유 계정(EOA)에 토큰을 보낼 때만 사용



  \> *CA에 토큰을 보낼 때는 TxTypeFeeDelegatedSmartContractExecution사용*

  \> *왜냐하면 트랜잭션이 하나의 목적만을 제공하도록 나눔*



\- 트랜잭션 과정

  \1. fee payer의 잔액은 거래 수수료의 금액만큼 감소

  \2. 보내는 사람의 nonce 1 증가

  \3. 클레이 `value` 가 받는 사람에게 전송



\- Signature of sender, fee payer / sender tx hash는 RLP Encoding



  \> *RLP Encoding : 데이터를 저장하거나 전송하는데 필요한 통일된 포맷 제공)*

  \>

  \> *RLP Encoding for Signature of the Sender 예시*



  \```javascript

  SigRLP = encode([encode([type, nonce, gasPrice, gas, to, value, from]), chainid, 0, 0])

  SigHash = keccak256(SigRLP)

  Signature = sign(SigHash, <the sender's private key>)

​                   

  f845f84325a09f8e49e2ad84b0732984398749956e807e4b526c786af3c5f7416b293e638956a06bf88342092f6ff9fabe31739b2ebfa1409707ce54a54693e91a6b9bb77df0e7

  \```



<br />



\#### TxTypeFeeDelegatedValueTransferMemo



\- 사용자가 특정 메시지와 함께 토큰을 보내고 싶을 때 사용



\- 단, 외부 소유 계정(EOA)에만 사용



  \> *CA는 TxTypeFeeDelegatedSmartContractExecution 사용*



\- 트랜잭션 과정은 위와 동일



\- Signature of sender, fee payer / sender tx hash / transaction hash는 RLP Encoding



<br/>



\#### TxTypeFeeDelegatedSmartContractDeploy



\- 수수료 위임(fee delegation)과 함께 smart contract를 배포

\- 트랜잭션 과정

  \1. fee payer의 잔액은 거래 수수료의 금액만큼 감소

  \2. 보내는 사람의 nonce 1 증가

  \3. smart contract 코드 작성 후 배포. 배포 address는 receipt의 contractAddrress를 통해 리턴됨

  \4. 클레이 `value`  가 받는 사람에게 전송

\- Signature of sender, fee payer / sender tx hash / transaction hash는 RLP Encoding



<br/>



\#### TxTypeFeeDelegatedSmartContractExecution



\- 주어진 데이터 `input` 을 입력하여 smart contract 실행



\- fee는 지정된 fee payer가 납부. smart contract account인 경우에만 허용



  \> *클레이를 EOA로 전송하려면 TxTypeFeeDelegatedValueTransfer 사용*



\- 트랜잭션 과정



  \1. attribute `to` 가 smart contract account인 경우에 `input` 에 따라 코드가 실행됨. 그렇지 않으면, 이 트랜잭션은 reject됨

  \2. fee payer의 잔액은 거래 수수료의 금액만큼 감소

  \3. 보내는 사람의 nonce 1 증가

  \4. `value` 가 주어졌다면 클레이를 `value` 만큼 smart contract로 전송. 이 contract는 클레이를 받기 위해 payable fallback function이 있어야됨



\- Signature of sender, fee payer / sender tx hash / transaction hash는 RLP Encoding



<br/>



\#### TxTypeFeeDelegatedAccountUpdate



\- 주어진 account의 key를 업데이트함

\- 트랜잭션 과정

  \1. fee payer의 잔액은 거래 수수료의 금액만큼 감소

  \2. 보내는 사람의 nonce 1 증가

  \3. account의 key는 attribute `key`로 업데이트

  \4. 이 트랜잭션이 실행되면, 이후에 account의 트랜잭션은 새로운 `key`로 검증됨

\- Signature of sender, fee payer / sender tx hash / transaction hash는 RLP Encoding



<br/>



\#### TxTypeFeeDelegatedCancel



\- 트랜잭션 pool에서 동일한 nonce의 트랜잭션 실행을 취소함

\- 트랜잭션 과정

  \1. fee payer의 잔액은 거래 수수료의 금액만큼 감소

  \2. 보내는 사람의 nonce 1 증가
